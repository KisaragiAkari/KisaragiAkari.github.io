<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn-us.imgs.moe/2023/01/26/63d1eb385309a.png"><link rel="icon" href="https://cdn-us.imgs.moe/2023/01/26/63d1eb385309a.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#003153"><meta name="author" content="yozora0908"><meta name="keywords" content="OI"><meta name="description" content="突破口永远在环上。   找环是常用操作，但是并没有一个合适的模板。 笔者在写这篇文章之前就做过一些基环树的简单题，但是每一次写的找环都不尽相同。仅仅用dfs的回溯模拟一个栈，显然是不够公式化的，且容易出 bug，因此我们需要确定一种可靠的写法。 关于dfn的那套理论再合适不过了。 当然这玩意只能找一个环。 12345678910111213141516int cnt, num, fa"><title>「NOIP Record」#2 基环树 - yozora0908&#39;s blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"yozora0908.top",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"#"},progressbar:{enable:!0,height_px:3,color:"#0076FF",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:null,onlypost:!0,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!1,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="yozora0908's blog" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>yozora0908&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://cdn-us.imgs.moe/2023/02/02/63db75d1e0be8.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="「NOIP Record」#2 基环树"></span></div><div class="mt-3"></div><div class="mt-1"></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">「NOIP Record」#2 基环树</h1><div class="markdown-body"><p>突破口永远在环上。</p><p> </p><p>找环是常用操作，但是并没有一个合适的模板。</p><p>笔者在写这篇文章之前就做过一些基环树的简单题，但是每一次写的找环都不尽相同。仅仅用<code>dfs</code>的回溯模拟一个栈，显然是不够公式化的，且容易出 bug，因此我们需要确定一种可靠的写法。</p><p>关于<code>dfn</code>的那套理论再合适不过了。</p><p>当然这玩意只能找一个环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt, num, fa[N], dfn[N], cir[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_cir</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    dfn[x]=++num;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<br>        <span class="hljs-type">int</span> y=to[i];<br>        <span class="hljs-keyword">if</span>(y==fa[x]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(dfn[y]) &#123;<br>            <span class="hljs-keyword">if</span>(dfn[y]&lt;dfn[x]) <span class="hljs-keyword">continue</span>;<br>            cir[++cnt]=y;<br>            <span class="hljs-keyword">while</span>(y!=x) &#123;<br>                cir[++cnt]=fa[y];<br>                y=fa[x];<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> fa[y]=x, <span class="hljs-built_in">get_cir</span>(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以使用拓扑排序。</p><p>最终没有入队的就是环上节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基环树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort1</span><span class="hljs-params">()</span></span>&#123; <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(in[i]==<span class="hljs-number">1</span>) q.<span class="hljs-built_in">push</span>(i);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<br>            <span class="hljs-type">int</span> y=to[i];<br>            <span class="hljs-keyword">if</span>(in[y]&gt;<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">// do sth.</span><br>                <span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">1</span>) q.<span class="hljs-built_in">push</span>(y);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 内向树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort2</span><span class="hljs-params">()</span></span>&#123; <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-keyword">if</span>(!in[i]) q.<span class="hljs-built_in">push</span>(i);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i;i=nxt[i]) &#123;<br>            <span class="hljs-type">int</span> y=to[i];<br>            <span class="hljs-comment">// do sth.</span><br>            <span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="luogu2607-zjoi2008-骑士">luogu2607 [ZJOI2008] 骑士</h3><blockquote><p>基环树森林， <span class="math inline">\(n\)</span> 个点。求带权最大独立集。</p><p><span class="math inline">\(n \le 10^6\)</span></p></blockquote><p>树的情况是平凡的。</p><p>基环树的本质是若干树挂在一个环上，因此对于环上每个节点为根都跑一遍。然后断环为链，钦定一个元素选还是不选，做两遍即可。</p><h3 id="luogu4381-ioi2008-island">luogu4381 [IOI2008] Island</h3><blockquote><p>求 <span class="math inline">\(n\)</span> 个点的基环树直径。</p><p><span class="math inline">\(n \le 10^6\)</span></p></blockquote><p>答案一定是环上两点连接它们子树的直径。</p><p>断环为链，这里采用复制一遍的方法。</p><p>答案就是 <span class="math display">\[ \max_{i \le j} \{d_i + d_j + dis(i,j)\} \]</span> 把 <span class="math inline">\(dis(i,j)\)</span> 拆成前缀和相减的形式，发现对于一个 <span class="math inline">\(j\)</span>，最优策略是前面距离不超过 <span class="math inline">\(n\)</span> 的最大值，单调队列维护。</p><h3 id="cf835f-roads-in-the-kingdom">CF835F Roads in the Kingdom</h3><blockquote><p><span class="math inline">\(n\)</span> 个结点的基环树，边有边权。需要从删去一条边，保证连通且最小化直径。</p></blockquote><p>首先删掉的边一定是环上的，否则不连通。</p><p>断开环上一边 <span class="math inline">\((x,y)\)</span>，此时的直径是环上 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的路径加上二者子树的直径，或者某个子树的直径。</p><p>而删边的影响仅仅是干掉某些环上的路径。</p><p>长度为 <span class="math inline">\(n\)</span> 的那个滑动窗口能够做到“删掉某条边”。</p><p>由于这个单调队列一次能干掉的决策只有一个，所以用<code>std::set</code>即可，但是要注意判断最优决策相等的情况，维护次大值。</p><h3 id="cf1454e-number-of-simple-paths">CF1454E Number of Simple Paths</h3><blockquote><p><span class="math inline">\(n\)</span> 点 <span class="math inline">\(n\)</span> 边的无向图，问一共有多少条简单路径。</p><p><span class="math inline">\(n \le 2 \cdot 10^5\)</span></p></blockquote><p>如果两个点之间的路径跨越环上某一部分，那么就有两条简单路径，否则只有一条。对环上每棵子树分别考虑即可。</p><h3 id="cf1770d-koxia-and-game">CF1770D Koxia and Game</h3><blockquote><p>给定 <span class="math inline">\(n\)</span> 和长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a,b\)</span>，考虑另一个序列 <span class="math inline">\(c\)</span>。</p><p>先手在第 <span class="math inline">\(i\)</span> 次操作，可以拿走可重集 <span class="math inline">\(\{a_i,b_i,c_i\}\)</span> 中的一个元素，后手再二选一拿走一个。</p><p>做完 <span class="math inline">\(n\)</span> 次操作后，如果后手拿走的所有元素是 <span class="math inline">\(1 \sim n\)</span> 的一个排列，那么先手胜，否则先手败。</p><p>求有多少个 <span class="math inline">\(c\)</span>，满足先手能胜利。对 <span class="math inline">\(998244353\)</span> 取模。</p><p><span class="math inline">\(n \le 10^5\)</span>，<span class="math inline">\(a_i,b_i \in [1,n]\)</span></p></blockquote><p>博弈，但并不是传统的博弈论题目。</p><p>正着想很困难，考虑先手能赢的条件。</p><p>对于 <span class="math inline">\(\{a_n,b_n,c_n\}\)</span>，如果不存在两者相同，那么无论先手拿走哪一个，后手都有办法使得先手输掉。所以 <span class="math inline">\(\{a_n,b_n,c_n\}\)</span> 存在两者相同是一个必要条件。</p><p>考虑 <span class="math inline">\(\{a_{n-1},b_{n-1},c_{n-1}\}\)</span>，假设 <span class="math inline">\(\{a_n,b_n,c_n\}\)</span> 满足上述条件，发现 <span class="math inline">\(\{a_{n-1},b_{n-1},c_{n-1}\}\)</span> 满足上述条件依然是必要的。</p><p>由此递归下去，得到对于任意 <span class="math inline">\(i\)</span>，<span class="math inline">\(\{a_i,b_i,c_i\}\)</span> 满足上述条件是充要的。</p><p>问题转化为对于任意 <span class="math inline">\(i\)</span>，要在 <span class="math inline">\((a_i,b_i)\)</span> 中选择一个数，求选出的数构成 <span class="math inline">\([1,n]\)</span> 的一个排列的方案数。对于 <span class="math inline">\(a_i = b_i\)</span> 的情况，对方案的贡献是 <span class="math inline">\(n\)</span>。</p><p>转化为图论问题。将 <span class="math inline">\(a_i\)</span> 与 <span class="math inline">\(b_i\)</span> 视为点，在 <span class="math inline">\((a_i,b_i)\)</span> 间连一条无向边，这样就会得到一些连通块。由数据范围可知最多有 <span class="math inline">\(n\)</span> 个点与 <span class="math inline">\(n\)</span> 条边。</p><p>由于一条边连接的两个点中必然有一个被选择且不允许重复（要构成排列），所以如果一个联通块点数不等于边数，无解。那么有解的连通块一定是一棵基环树。</p><p>容易发现方案只有 <span class="math inline">\(2\)</span> 种，区别在环上选择的方向。环也有可能是自环，就是 <span class="math inline">\(a_i=b_i\)</span> 的情况，方案是 <span class="math inline">\(1\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>		c=<span class="hljs-built_in">getchar</span>();<br>	&#125;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>, mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">int</span> T, n, ans, fg, v[N], a[N], b[N];<br><span class="hljs-type">int</span> cnt;<br>vector&lt;<span class="hljs-type">int</span>&gt; p[N];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<br>	<span class="hljs-type">int</span> fa[N], sz[N], cnte[N];<br>	<span class="hljs-type">bool</span> slp[N];<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;;<br>		<span class="hljs-type">int</span> tx=<span class="hljs-built_in">get</span>(x), ty=<span class="hljs-built_in">get</span>(y);<br>		<span class="hljs-keyword">if</span>(fa[tx]!=ty) fa[tx]=ty, sz[ty]+=sz[tx], cnte[ty]+=cnte[tx];<br>		++cnte[ty];<br>		slp[ty]|=slp[tx];<br>		<span class="hljs-keyword">if</span>(x==y) slp[ty]=<span class="hljs-number">1</span>;<br>	&#125;<br>    <span class="hljs-comment">// 经过某道题的教训，终于老老实实写些并查集维护起来相对容易的信息了</span><br>&#125; dsu;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>	n=<span class="hljs-built_in">read</span>();<br>	ans=<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=<span class="hljs-number">0</span>, dsu.fa[i]=i, dsu.cnte[i]=dsu.slp[i]=<span class="hljs-number">0</span>, dsu.sz[i]=<span class="hljs-number">1</span>, a[i]=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br>		b[i]=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-type">int</span> x=a[i], y=b[i];<br>		dsu.<span class="hljs-built_in">merge</span>(x,y);<br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(i==dsu.<span class="hljs-built_in">get</span>(i)) &#123;<br>		<span class="hljs-keyword">if</span>(dsu.sz[i]!=dsu.cnte[i]) &#123;<br>			<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(dsu.slp[i]) (ans*=n)%=mod;<br>		<span class="hljs-keyword">else</span> (ans*=<span class="hljs-number">2</span>)%=mod;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	T=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-keyword">while</span>(T--) <span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>贴上<code>DFS</code>版本的 std。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">int</span> n, a[N], b[N];<br>vector &lt;<span class="hljs-type">int</span>&gt; G[N];<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-type">int</span> vertex, edge, self_loop;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (vis[x]) <span class="hljs-keyword">return</span> ;<br>	vis[x] = <span class="hljs-literal">true</span>;<br>	vertex++;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : G[x]) &#123;<br>		edge++;<br>		<span class="hljs-built_in">dfs</span>(y);<br>		<span class="hljs-keyword">if</span> (y == x) self_loop++;<br> 	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b[i]);<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) G[i].<span class="hljs-built_in">clear</span>();<br> <br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		G[a[i]].<span class="hljs-built_in">push_back</span>(b[i]);<br>		G[b[i]].<span class="hljs-built_in">push_back</span>(a[i]);<br>	&#125;<br> <br>	<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br> <br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) vis[i] = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>		<span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span> ;<br>		vertex = <span class="hljs-number">0</span>;<br>		edge = <span class="hljs-number">0</span>;<br>		self_loop = <span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">dfs</span>(i);<br>		<span class="hljs-keyword">if</span> (edge != <span class="hljs-number">2</span> * vertex) ans = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self_loop) ans = <span class="hljs-number">1ll</span> * ans * n % P;<br> 		<span class="hljs-keyword">else</span> ans = ans * <span class="hljs-number">2</span> % P;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> t;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);<br>	<span class="hljs-keyword">while</span> (t--) <span class="hljs-built_in">solve</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cf512d-fox-and-travelling">CF512D Fox And Travelling</h3><p><del>不知道和基环树有什么关系</del>。</p><p>首先可以发现，环中的节点和链接两个环的链上的节点是不能选的。</p><p>用上文的无向图拓扑排序可以找到所有上述节点，这样的话就会得到一个森林。</p><p>注意选点是有顺序的，考虑一棵树中，一定是从叶子开始自底向上选，且如果一个点没有被选，其一定不会产生任何贡献。</p><p>设 <span class="math inline">\(f_{x,i}\)</span> 为以 <span class="math inline">\(x\)</span> 为根的子树，选择 <span class="math inline">\(i\)</span> 个点，其中 <span class="math inline">\(x\)</span> 必须选择的方案数。 <span class="math display">\[ g_j = \binom{j}{k} \times f_{x,k} \times f_{y,j-k} \]</span> <span class="math inline">\(\binom{j}{k}\)</span> 的含义是从 <span class="math inline">\(j\)</span> 个位置中选择 <span class="math inline">\(k\)</span> 个给当前以 <span class="math inline">\(x\)</span> 为根的子树。</p><p>能发现 <span class="math inline">\(x\)</span> 是最后被选择的。</p><p>对于挂在环上的树，这种选择方式显然是唯一的。</p><p>考虑孤立的树。由于 <span class="math inline">\(n \le 100\)</span>，所以直接以每个点为根做一次树形 DP。设选择 <span class="math inline">\(i\)</span> 个节点，这样只能保证选 <span class="math inline">\(sz_{root}\)</span> 个点时没有重复。</p><p>考虑选出的 <span class="math inline">\(i\)</span> 个节点，这个方案一定在以剩下 <span class="math inline">\(sz_{root}-i\)</span> 个节点为根时都被算过一次，除掉即可。</p><h3 id="luogu5049-noip2018-提高组-旅行-加强版">luogu5049 [NOIP2018 提高组] 旅行 加强版</h3><blockquote><p>给定一棵 <span class="math inline">\(n\)</span> 个点的树或基环树，起点为 <span class="math inline">\(1\)</span>。</p><p>有两种操作</p><ol type="1"><li>到达一个当前点能直接到达的，没有到达过的点。</li><li>沿着到达当前点的边退回这条边的另一个端点。</li></ol><p>要求遍历所有点，最小化节点遍历的字典序。</p><p><span class="math inline">\(n \le 5 \cdot 10^5\)</span></p></blockquote><p>对于一棵树，必须按照子节点编号递增的顺序<code>DFS</code>，所以下文访问顺序指的就是兄弟节点之间的编号顺序。</p><p>对于基环树，多了的操作是「从环上往后退」。</p><p>什么时候可以往后退呢？当且仅当对于环上的父子节点 <span class="math inline">\((x,y)\)</span>，<span class="math inline">\(y\)</span> 是 <span class="math inline">\(x\)</span> 最后遍历的子节点（这样才能从另一边绕回来），同时回溯到 <span class="math inline">\(y\)</span> 的祖先时，能够到达编号小于 <span class="math inline">\(y\)</span> 的点。</p><p>更进一步地，如果选择了退回，那么不可能再次后退。所以这个编号小于 <span class="math inline">\(y\)</span> 的点，一定是回溯过程中遇到的第一个祖先的儿子，满足它是这个祖先下一个应访问的节点，否则就无法遍历到了。</p><p>因此就变成了树的做法。</p><p>如何实现？对于节点 <span class="math inline">\(x\)</span>，维护最小子节点编号，<code>DFS</code>时记录之，这样一定能找到最优退回的地方。</p><p>顺带一提，优先队列的内存优化优于队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>		c=<span class="hljs-built_in">getchar</span>();<br>	&#125;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, m, num, fg, root, dfn[N], fa[N];<br><span class="hljs-type">bool</span> v[N], cir[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; p[N], ans;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span> </span>&#123;<br>	ans.<span class="hljs-built_in">pb</span>(x);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa) <span class="hljs-built_in">dfs</span>(y,x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_cir</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    dfn[x]=++num;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(y!=fa[x]) &#123;<br>        <span class="hljs-keyword">if</span>(dfn[y]) &#123;<br>            <span class="hljs-keyword">if</span>(dfn[y]&lt;dfn[x]) <span class="hljs-keyword">continue</span>;<br>            cir[y]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(y!=x) &#123;<br>            	cir[fa[y]]=<span class="hljs-number">1</span>;<br>            	y=fa[y];<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> fa[y]=x, <span class="hljs-built_in">get_cir</span>(y);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> pre)</span> </span>&#123;<br>	v[x]=<span class="hljs-number">1</span>;<br>	ans.<span class="hljs-built_in">pb</span>(x);<br>	priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:p[x]) <span class="hljs-keyword">if</span>(!v[y]) q.<span class="hljs-built_in">push</span>(y);<br>	<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<br>		<span class="hljs-type">int</span> y=q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span>(!fg&amp;&amp;q.<span class="hljs-built_in">empty</span>()&amp;&amp;cir[x]&amp;&amp;cir[y]&amp;&amp;pre&lt;y) &#123;<br>			fg=<span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(v[y]) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">if</span>(cir[x]&amp;&amp;q.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">DFS</span>(y,q.<span class="hljs-built_in">top</span>());<br>		<span class="hljs-keyword">else</span> <span class="hljs-built_in">DFS</span>(y,pre);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<br>		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<br>		p[x].<span class="hljs-built_in">pb</span>(y), p[y].<span class="hljs-built_in">pb</span>(x);<br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-built_in">sort</span>(p[i].<span class="hljs-built_in">begin</span>(),p[i].<span class="hljs-built_in">end</span>());<br>	<span class="hljs-keyword">if</span>(m==n<span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">else</span> <span class="hljs-built_in">get_cir</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1e9</span>);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:ans) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,x);<br>	<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>欲穷千里目，更上一层楼。</li></ul><h3 id="luogu8288-daoi-r1fireworks">luogu8288 「DAOI R1」Fireworks</h3><p>题面较复杂，就不放了。</p><p>本题相当缝合。</p><p>坚持自己的想法，让我得到了无数次 WA。最终也是放弃了自己的框架，参考了 std。</p><p>这么多次写挂，背后的原因，不全是因为此题代码实现相对复杂。经过教练的指导，我也明白了我深层的不足。</p><p>为了不留下遗憾，勇敢面对吧！</p><p>连边 <span class="math inline">\((a_x \rightarrow x)\)</span>，权值 <span class="math inline">\(b_x\)</span>。</p><p>如果没有系列的限制，相当于在外向树森林上做一个简单 DP。</p><p>有了限制，就把同一个系列的点缩成一个，其权值为所有点权之和。</p><p>设 <span class="math inline">\(f_{x,0/1}\)</span> 为以 <span class="math inline">\(x\)</span> 为根的子树，<span class="math inline">\(x\)</span> 选还是不选的最大价值。每个节点的入边最多为 <span class="math inline">\(1\)</span>，因此无入度点一定不会进入环，直接搜。</p><p>如果有环，强制环上一点选或者不选，两次 DP 即可。</p><p>设主节点为 <span class="math inline">\(p\)</span>，对于非主要点 <span class="math inline">\(x\)</span>，如果 <span class="math inline">\(a_x\)</span> 所在系列是 <span class="math inline">\(x\)</span> 所在的系列，让点权减少 <span class="math inline">\(b_x\)</span>；否则如果 <span class="math inline">\(a_x\)</span> 所在的系列和 <span class="math inline">\(a_p\)</span> 所在系列相同，就让边权加上 <span class="math inline">\(b_x\)</span>。</p><p>注意如果 <span class="math inline">\(a_p\)</span> 就是 <span class="math inline">\(p\)</span> 所在系列，优先执行前者。而这对应的就是无入度点。</p><p>如果有点不属于任何一个系列，新建立一个系列，只有这个点。</p><p>主要问题在于实现。</p><p>代码详细解释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function">ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>	ll a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>		c=<span class="hljs-built_in">getchar</span>();<br>	&#125;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, m, num, cnt, a[N], p[N], bel[N];<br>ll b[N], v[N], v2[N], ww[N], f[N][<span class="hljs-number">2</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; s[N];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,ll&gt; &gt; g[N];<br>pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; cir[N];<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<br>	<span class="hljs-type">int</span> fa[N];<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<br>&#125; dsu;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> i)</span> </span>&#123;<br>	f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[x][<span class="hljs-number">1</span>]=v2[x];<br>    <span class="hljs-comment">// 赋初值避开清空数组</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:g[x]) &#123;<br>		<span class="hljs-type">int</span> y=t.first;<br>		ll z=t.second;<br>		<span class="hljs-built_in">dfs</span>(y,i);<br>        <span class="hljs-comment">// 出边可能不止有一条。虽然断开了环上那条边，但cir[i].second也可能到达其他点</span><br>        <span class="hljs-comment">// 因此还要往下DFS，这时候就能看出避免连环上这条边的重要性</span><br>        <span class="hljs-comment">// 只需要在更新cir[i].second的父节点时候特判</span><br>		<span class="hljs-keyword">if</span>(i&amp;&amp;y==cir[i].second) &#123;<br>			f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-ww[i]);<br>			f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-ww[i]-z);<br>            <span class="hljs-comment">// 无论如何必须减掉i这条边的权值</span><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);<br>			f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-z);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=<span class="hljs-built_in">read</span>(), a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>();<br>    <br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<br>		p[++num]=<span class="hljs-built_in">read</span>(); <span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>();<br>		dsu.fa[num]=num;<br>		<span class="hljs-keyword">while</span>(k--) &#123;<br>			<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<br>			v2[num]+=v[x], bel[x]=num;<br>			s[num].<span class="hljs-built_in">pb</span>(x);<br>		&#125;<br>        <span class="hljs-comment">// num表示有多少个系列</span><br>        <span class="hljs-comment">// 只有系列才是有用的，因此直接重新编号，避免不必要的麻烦</span><br>        <span class="hljs-comment">// 笔者在写的时候，没有进行重新编号，而是用DSU进行缩点</span><br>        <span class="hljs-comment">// 不重新编号，会带来各种各样的麻烦</span><br>        <span class="hljs-comment">// 重新编号则没有什么坏处</span><br>        <span class="hljs-comment">// 因为原来的点的编号在预处理完之后就没有任何用处了</span><br>	&#125;<br>    <br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!bel[i]) &#123;<br>		p[++num]=i, bel[i]=num, v2[num]=v[i];<br>		s[num].<span class="hljs-built_in">pb</span>(i);<br>		dsu.fa[num]=num;<br>        <span class="hljs-comment">// 处理不在任何系列中的点</span><br>	&#125;<br>    <br>    <br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,num) &#123;<br>		<span class="hljs-type">int</span> tp=bel[a[p[i]]];<br>		ll res=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s[i]) &#123;<br>			<span class="hljs-type">int</span> tx=bel[a[x]];<br>			<span class="hljs-keyword">if</span>(tx==i) v2[i]-=b[x];<br>            <span class="hljs-comment">// 优先执行这个</span><br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tx==tp) res+=b[x];<br>		&#125;<br>		<span class="hljs-keyword">if</span>(tp==i) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 无入度点</span><br>		vis[i]=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==dsu.<span class="hljs-built_in">get</span>(tp)) &#123;<br>            <span class="hljs-comment">// DSU判环</span><br>            <span class="hljs-comment">// 但注意不要烦笔者这样的错误</span><br>            <span class="hljs-comment">// 突然降智，过于依赖DSU的结构，用DSU存每个连通块那一条环上边</span><br>            <span class="hljs-comment">// 自找麻烦罢了</span><br>			cir[++cnt].first=i, cir[cnt].second=tp, ww[cnt]=res;<br>            <span class="hljs-comment">// ww[cnt]为这条边的权值</span><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			dsu.fa[dsu.<span class="hljs-built_in">get</span>(i)]=dsu.<span class="hljs-built_in">get</span>(tp);<br>			g[tp].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">make_pair</span>(i,res));<br>            <span class="hljs-comment">// 成环的时候不连边，保证DFS无环</span><br>            <span class="hljs-comment">// 否则就连反边</span><br>		&#125;<br>	&#125;<br>	ll ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,num) <span class="hljs-keyword">if</span>(!vis[i]) &#123;<br>		<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);<br>		ans+=<span class="hljs-built_in">max</span>(f[i][<span class="hljs-number">0</span>],f[i][<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 这样的点可以直接搜</span><br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) &#123;<br>		<span class="hljs-type">int</span> x=cir[i].first;<br>		ll aa=<span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">dfs</span>(x,i);<br>        <span class="hljs-comment">// 强制cir[i].first必须选，cir[i].second-&gt;cir[i].first必须考虑</span><br>		aa=f[x][<span class="hljs-number">1</span>];<br>		<span class="hljs-built_in">dfs</span>(x,<span class="hljs-number">0</span>);<br>		aa=<span class="hljs-built_in">max</span>(aa,f[x][<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 不选，不考虑cir[i].second-&gt;cir[i].first</span><br>		ans+=aa;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>不要过于依赖提交，认真分析程序。</li><li>思路应该更广阔些，本题应该在发现建图后就是外向树森林，进而分析图的特殊形态而简化实现</li></ul><p>必须要把我的某一版 sb 程序贴出来，以作警示。</p><p>想不到还有 30pts。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, m, ans, v[N], vv[N], a[N], b[N], p[N], f[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> to[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">bool</span> vis[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; s[N];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; g[N];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<br>	<span class="hljs-type">int</span> fa[N];<br>	pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; cir[N];<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) fa[i]=i, cir[i].fi=cir[i].se=<span class="hljs-number">0</span>; &#125;<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x==fa[x]? x:fa[x]=<span class="hljs-built_in">get</span>(fa[x]); &#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> </span>&#123;<br>		<span class="hljs-type">int</span> dx=<span class="hljs-built_in">get</span>(x), dy=<span class="hljs-built_in">get</span>(y);<br>		<span class="hljs-keyword">if</span>(dx!=dy) fa[dx]=dy;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x!=y) cir[dy]=&#123;x,y&#125;;<br>	&#125;<br>&#125; dsu, dsu2;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> root)</span> </span>&#123;<br>	vis[x]=<span class="hljs-number">1</span>;<br>	f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>, f[x][<span class="hljs-number">1</span>]=v[x];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:g[x]) &#123;<br>		<span class="hljs-type">int</span> y=t.fi, z=t.se;<br>		<span class="hljs-keyword">if</span>(y==root) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">dfs</span>(y,root);<br>		f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);<br>		f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-z);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> root)</span> </span>&#123;<br>	f[x][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>	f[x][<span class="hljs-number">1</span>]=v[x];<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t:g[x]) &#123;<br>		<span class="hljs-type">int</span> y=t.fi, z=t.se;<br>		<span class="hljs-keyword">if</span>(y==root) &#123;<br>			f[x][<span class="hljs-number">1</span>]-=z;<br>			<span class="hljs-keyword">continue</span>;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">dfs1</span>(y,root);<br>		f[x][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]);<br>		f[x][<span class="hljs-number">1</span>]+=<span class="hljs-built_in">max</span>(f[y][<span class="hljs-number">0</span>],f[y][<span class="hljs-number">1</span>]-z);<br>	&#125;<br>	<span class="hljs-comment">// printf(&quot;x=%lld f=%lld %lld\n&quot;,x,f[x][0],f[x][1]);</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">redirect</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;<br>		<span class="hljs-type">int</span> y=to[i][<span class="hljs-number">0</span>], z=to[i][<span class="hljs-number">1</span>];<br>		g[y].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">make_pair</span>(i,z));<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rebuild</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;<br>		dsu2.<span class="hljs-built_in">merge</span>(i,to[i][<span class="hljs-number">0</span>]);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) v[i]=<span class="hljs-built_in">read</span>(), a[i]=<span class="hljs-built_in">read</span>(), b[i]=<span class="hljs-built_in">read</span>();<br>	dsu.<span class="hljs-built_in">init</span>(), dsu2.<span class="hljs-built_in">init</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<br>		p[i]=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-type">int</span> k=<span class="hljs-built_in">read</span>();<br>		<span class="hljs-keyword">while</span>(k--) &#123;<br>			<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>();<br>			<span class="hljs-keyword">if</span>(x==p[i]) <span class="hljs-keyword">continue</span>;<br>			v[p[i]]+=v[x];<br>			s[p[i]].<span class="hljs-built_in">pb</span>(x);<br>			dsu.<span class="hljs-built_in">merge</span>(x,p[i]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;<br>		to[i][<span class="hljs-number">0</span>]=dsu.<span class="hljs-built_in">get</span>(a[i]), to[i][<span class="hljs-number">1</span>]=b[i];<br>		<span class="hljs-keyword">if</span>(!s[i].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:s[i]) &#123;<br>			<span class="hljs-type">int</span> px=dsu.<span class="hljs-built_in">get</span>(a[x]);<br>			<span class="hljs-keyword">if</span>(px==i) v[i]-=b[x];<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(px==to[i][<span class="hljs-number">0</span>]) to[i][<span class="hljs-number">1</span>]+=b[x];<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-built_in">redirect</span>();<br>	<br>	<span class="hljs-built_in">rebuild</span>();<br>	<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;dsu.<span class="hljs-built_in">get</span>(i)==i) &#123;<br>		<span class="hljs-type">int</span> aa=<span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> root=<span class="hljs-number">0</span>, pi=dsu2.<span class="hljs-built_in">get</span>(i);<br>		<span class="hljs-keyword">if</span>(dsu2.cir[pi].fi!=<span class="hljs-number">0</span>) root=dsu2.cir[pi].fi;<br>		<span class="hljs-keyword">else</span> &#123;<br>			root=pi;<br>			<span class="hljs-built_in">dfs</span>(root,root);<br>			ans+=<span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">0</span>],f[root][<span class="hljs-number">1</span>]);<br>			<span class="hljs-keyword">continue</span>;<br>		&#125;<br>		<span class="hljs-built_in">dfs</span>(root,root);<br>		aa=f[root][<span class="hljs-number">0</span>];<br>		<span class="hljs-built_in">SET</span>(f,<span class="hljs-number">0</span>);<br>		<span class="hljs-built_in">dfs1</span>(root,root);<br>		aa=<span class="hljs-built_in">max</span>(aa,f[root][<span class="hljs-number">1</span>]);<br>		ans+=aa;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="luogu6890-ceoi2006-link">luogu6890 [CEOI2006] Link</h3><p>首先执行拓扑排序，将 <span class="math inline">\(1\)</span> 和无入度点加入队列，<span class="math inline">\(1\)</span> 一定会对它们连边。每求出一个 <span class="math inline">\(f_x &gt; k\)</span> 就将其置为 <span class="math inline">\(1\)</span>，再更新别的点。</p><p>把环拎出来，考虑别的点进入环后只能到达环上一个区间，可以用差分维护。这些点肯定不需要连边。对于剩下的点，如果第一个连边的点确定了，那么就直接贪心。</p><p>考虑枚举第一个连边的点，设环长为 <span class="math inline">\(m\)</span>，发现只会跳 <span class="math inline">\(O(\frac{m}{k})\)</span> 次。由于开头 <span class="math inline">\(k\)</span> 个点必然至少有一个连边，所以复杂度就是 <span class="math inline">\(O(m)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> uint unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PII pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MP make_pair</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CPY(a,b) memcpy(a,b,sizeof(b))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,j,k) for(int i=(j);i&lt;=(k);++i)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> per(i,j,k) for(int i=(j);i&gt;=(k);--i)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>		<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;<br>		c=<span class="hljs-built_in">getchar</span>();<br>	&#125;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) a=a*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>, c=<span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">return</span> a*f;<br>&#125;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> n, m, k, ans, cnt, to[N], in[N], f[N], c[N];<br><span class="hljs-type">bool</span> v[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; cir[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span> </span>&#123;<br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br>		<span class="hljs-keyword">if</span>(!in[i]||i==<span class="hljs-number">1</span>) &#123;<br>			f[i]=i==<span class="hljs-number">1</span>? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>) ++ans;<br>			q.<span class="hljs-built_in">push</span>(i);<br>		&#125; <span class="hljs-keyword">else</span> f[i]=k+<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()) &#123;<br>		<span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>		v[x]=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span>(f[x]&gt;k) ++ans, f[x]=<span class="hljs-number">1</span>;<br>		<span class="hljs-type">int</span> y=to[x];<br>		<span class="hljs-keyword">if</span>(y&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>		f[y]=<span class="hljs-built_in">min</span>(f[y],f[x]+<span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">if</span>(--in[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getcir</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) <span class="hljs-keyword">if</span>(!v[i]) &#123;<br>		v[i]=<span class="hljs-number">1</span>;<br>		cir[++cnt].<span class="hljs-built_in">pb</span>(<span class="hljs-number">114514</span>), cir[cnt].<span class="hljs-built_in">pb</span>(i);<br>		<span class="hljs-type">int</span> x=i;<br>		<span class="hljs-keyword">while</span>(to[x]!=i) v[to[x]]=<span class="hljs-number">1</span>, cir[cnt].<span class="hljs-built_in">pb</span>(to[x]), x=to[x];<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>	m=cir[x].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>	<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,(m+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">3</span>);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<br>		<span class="hljs-keyword">if</span>(f[cir[x][i]]&gt;k) <span class="hljs-keyword">continue</span>;<br>		<span class="hljs-type">int</span> R=i+k-f[cir[x][i]];<br>		<span class="hljs-keyword">if</span>(R&lt;=m) ++c[i], --c[R+<span class="hljs-number">1</span>];<br>		<span class="hljs-keyword">else</span> ++c[i], --c[m+<span class="hljs-number">1</span>], ++c[<span class="hljs-number">1</span>], --c[R+<span class="hljs-number">1</span>-m];<br>	&#125;<br>	vector&lt;<span class="hljs-type">int</span>&gt; v; v.<span class="hljs-built_in">pb</span>(<span class="hljs-number">1919810</span>);<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,m) &#123;<br>		c[i]+=c[i<span class="hljs-number">-1</span>];<br>		<span class="hljs-keyword">if</span>(c[i]==<span class="hljs-number">0</span>) v.<span class="hljs-built_in">pb</span>(i);<br>	&#125;<br>	<span class="hljs-type">int</span> res=v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, mm=v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mm,k);++i) &#123;<br>		<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=v[i];j&lt;v[i]+m;++j) &#123;<br>			<span class="hljs-type">int</span> jj=j&gt;m? j-m:j;<br>			<span class="hljs-keyword">if</span>(c[jj]==<span class="hljs-number">0</span>) ++a, j+=k<span class="hljs-number">-1</span>;<br>		&#125;<br>		res=<span class="hljs-built_in">min</span>(res,a);<br>	&#125;<br>	ans+=res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	n=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,n) &#123;<br>		<span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>();<br>		to[x]=y, ++in[y];<br>	&#125;<br>	<span class="hljs-built_in">toposort</span>();<br>	<span class="hljs-built_in">getcir</span>();<br>	<span class="hljs-built_in">rep</span>(i,<span class="hljs-number">1</span>,cnt) <span class="hljs-built_in">solve</span>(i);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Record/" class="category-chain-item">Record</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E8%AE%A1%E6%95%B0/" class="print-no-link">#计数</a> <a href="/tags/DP/" class="print-no-link">#DP</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" class="print-no-link">#图论</a> <a href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" class="print-no-link">#博弈论</a> <a href="/tags/%E5%9F%BA%E7%8E%AF%E6%A0%91/" class="print-no-link">#基环树</a></div></div><div class="license-box my-3"><div class="license-title"><div>「NOIP Record」#2 基环树</div><div>https://yozora0908.top/2023/noip-record-2/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>yozora0908</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年5月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/noip-record-3/" title="「NOIP Record」#3 Trie"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">「NOIP Record」#3 Trie</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/noip-record-1/" title="「NOIP Record」#1 树形DP（1）"><span class="hidden-mobile">「NOIP Record」#1 树形DP（1）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments"><div id="giscus" class="giscus"></div><script type="text/javascript">Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"yozora0908/MyGiscus","repo-id":"R_kgDOKLq9Ag","category":"Announcements","category-id":"DIC_kwDOKLq9As4CY38c","theme-light":"light_protanopia","theme-dark":"dark_protanopia","mapping":"title","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN","loading":"lazy","strict":1};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light_protanopia';
        var dark = 'dark_protanopia';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script>if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>